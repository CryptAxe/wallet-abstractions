#ifndef ABSTRACTIONS_WALLET_HPP
#define ABSTRACTIONS_WALLET_HPP

#include "output.hpp"
#include "set.hpp"
#include "link.hpp"

namespace abstractions
{
    
    template <typename out>
    N balance(output::value<out> v, set<out> wallet) {
        if (wallet == nullptr) return 0;
        return v(wallet->First) + balance(v, wallet->Rest);
    }
    
    template <typename key, typename tag>
    struct notebook {
        map<tag, key> Addresses;
        
        vector<one_way<key, tag>> Tags;
        
        // the notebook is invalid if there is any tag in
        // Addresses which was not generated by the corresponding
        // key by one of the functions in Tags. 
        bool valid() const {
            for (tag t : Addresses) for (one_way<key, tag> f : Tags) {
                if (t == f(Addresses[t])) continue;
                return false;
            }
        }
        
        notebook(map<tag, key> a, vector<one_way<key, tag>> t) : Addresses(a), Tags(t) {}
    };
    
    template <typename out, typename key, typename script, typename tag>
    struct wallet {
        const set<out> Outputs;
        
        output::value<out> GetValue;
        output::script<out, script> GetScript;
        
        map<pattern<script>, tags<tag, script>> Patterns;
        
        N Balance;
        
        map<tag, out> ObservedTags;
        
        bool valid() {
            if (GetValue == nullptr || GetScript == nullptr) return false;
            
            std::map<tag, out> tags;
            set<out> outputs{};
            
            // Check that every output matches a pattern. 
            for(set<out> outs = Outputs; outs != nullptr; outs = outs->Next) {
                for(pattern<script> match : Patterns) if (match(outs->First)) {
                    for (tag t : Patterns[match](outs->First)) tags.insert(std::make_pair(t, outs->First));
                    outputs = outputs + outs->First;
                    continue;
                }
                return false;
            }
            
            // check that for every output a key and tag function
            // exist such that the generated tags is among
            // those which can be extracted from the output. 
            for (set<key> keys = Keys; keys != nullptr; keys = keys->Next) {
                for (one_way<key, tag> f : Tags) {
                    auto x = tags.find(f(keys->First));
                    if (x != tags.end()) outputs -= *x;
                }
                return false;
            }
            
            return outputs == nullptr;
        }
        
        wallet(
            set<out> o,
            output::value<out> gv,
            output::script<out, script> gs,
            map<pattern<script>, tags<tag, script>> p,
            map<tag, out> ot,
            N b) 
        : Outputs(o), GetValue(gv), GetScript(gs), Patterns(p), Balance(b), ObservedTags(ot) {}
    };
}

#endif
